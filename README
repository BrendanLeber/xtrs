README.tpm
Tim Mann <mann@pa.dec.com>
8/5/97

As computer scientists, we always long for something bigger and better
than what we have now.  Give us a megabyte, and we want a gigabyte.
Give us an emulated TRS-80 Model I with Level II BASIC and cassette,
and we long for the Expansion Interface and floppy disk drives.  Give
us that, and we want a Model III!

This is a snapshot of the work I've been doing on xtrs to add these
niceties.  My main additions over xtrs-1.0 have been floppy disk
emulation, timer interrupt emulation, a kludge to import and export
data to the host system, Model III mode, a rewrite of the keyboard
handling, and a bunch of bug fixes and minor improvements.

This project has been a real (48KB?) trip down memory lane for me.  I
worked as a programmer for Logical Systems, who produced LDOS, during
1980-81 before I went to grad school.  I no longer own a TRS-80, but I
recently found a box in my storage closet containing all my Model I
hardware manuals, schematics, ROM disassemblies, and even the assembly
listing for a version of the LDOS Percom Doubler driver that I helped
write.

At some point it would be fun to extend this code to emulate a Model 4
or 4P.  I don't have the technical data for those systems, however.

****
Technical information omitted from the man page
****

* Interrupts

The emulator supports only interrupt mode 1.  It will complain if your
program enables interrupts after powerup without executing an im 1
instruction first.  All Model I and III software does this, as these
machines supported only im 1.

The Model I had a 40 Hz "heartbeat" interrupt, while the Model III
used 30 Hz.  The emulator approximates this rather well even on a
system where clock ticks come at some frequency that isn't divisible
by the emulated frequency (e.g., 100 Hz on Intel Linux), as long as
the true frequency is not slower than the emulated frequency.  The
emulator has a notion of the absolute time at which each tick is
supposed to occur, and it asks the host system to wake it up at each
of those times.  The net result is that some ticks may be late, but
there are always the proper number of ticks per second.  For example,
running in Model I mode on Intel Linux you'd see this pattern: (tick,
30ms, tick, 20ms, ...) instead of seeing ticks every 25ms.

The debugger has some extra support to keep interrupts from making
life intolerable.  The "step" command suppresses the normal test for a
pending interrupt at the end of each instruction.  A "stepint" command
is available if you really want to allow an interrupt.  If you do this
while the emulated CPU has interrupts enabled, you'll usually find
that your next emulated instruction is at 0038H (the im 1 interrupt
vector).  New commands "timeroff" and "timeron" let you turn the
emulated timer off entirely, which is useful while tracing (for
example).  None of these features interfere with the emulated IFF1 and
IFF2 (interrupt enable flip-flop) state.

Note: Currently there is a bug in GNU readline() that makes it
incompatible with my timer interrupt implementation.  Readline thinks
that it is always supposed to clean up its state and exit when a
SIGALRM comes in, but in fact, I handle the signal and continue the
read system call.  I've reported this bug to readline's maintainer.

* Data import/export

There are two mechanisms for getting data into and out of the
emulator.  See trs_imp_exp.h for technical details.  The old way that
uses I/O ports is likely to go away eventually.  Before this can
happen, either import.z and export.z need to be fixed to work under
NEWDOS and friends, or import.bas and export.bas need to be hacked to
use the new mechanism by calling out to assembly code.

The new mechanism is quite flexible.  It's a tempting thought to
implement hard disk emulation by writing an LDOS hard disk driver that
uses it.  This would save all the bother of getting technical data on
a real TRS-80 hard disk controller, finding the drivers for it, and
emulating the controller well enough that the drivers work.  On the
other hand, it would require writing Z-80 assembly code, which I find
quite painful now that I'm out of practice.

* Minor features

I put in a silly kludge that lets LDOS know the correct date whenever
it boots up.  It simulates the case where you just rebooted LDOS
without power cycling and the date was left in memory.  Unfortunately
LDOS doesn't provide a way to do this trick with the time of day.

* Bug fix history

I fixed bugs in the instructions rrc, inc ix, inc iy, sra, and neg.  I
didn't notice the sra bug until I tried to get Model III mode working;
the Model III LDOS disk driver uses it.  The neg bug was keeping the
break key from working right under LDOS in xtrs-1.3 and earlier.

I got the emulator running both Linux and Digital Unix.  Now it might
have minor problems elsewhere, on less ANSI- and POSIX-compliant
systems.

I fixed two bugs in the disassembler.  The ld (bc),a instruction was
erroneously disassembled as ld bc,a, and instructions that start "dd
cb" or "fd cb" were not disassembled; for example: bit 7,(iy+03h).

I fixed some bugs in emulated cassettes.  Formerly if you tried to
append more stuff to an emulated cassette, it would smash whatever was
already there.  If you tried to read from a cassette with nothing on
it, it would lock up so hard that even the emulated boot button
wouldn't work.  Now at least the boot button works.

SIGIO is now used in a much safer way than before, and the emulator
will work without it if needed.

I reworked the keyboard support substantially.  A full state vector is
now kept, including all 64 possible TRS-80 keys.  Key queueing is now
always used, and a "stretching" feature prevents the emulated keyboard
state from changing too often, to avoid losing keystrokes.  Keyboard
response is quite snappy and reliable now.  I added enough key
mappings that it should be possible to do about everything you could
do with a real TRS-80 keyboard (and more than on a Model I, because
modern keyboards have N-key rollover).  More key mappings are easily
added by changing tables; there is very little special-case code.

I did some work on the KBWAIT feature, which tries to avoid burning
host CPU cycles when the emulated program is sitting in a loop polling
the keyboard.  It now works in a lot more cases.
